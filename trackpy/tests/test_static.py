from trackpy.static import *
import pandas as pd
import numpy as np
from numpy.testing import assert_equal, assert_almost_equal, assert_array_less
from trackpy.static import cluster
from trackpy.tests.common import StrictTestCase


def _points_ring3D(r_edges, dr, n):
    """Returns x, y, z array of points comprising shells extending from r to
    r_dr. n determines the number of points in the ring. Rings are generated by
    constructing a unit sphere and projecting every point onto a shell of
    thickness dr"""

    refx_all, refy_all, refz_all = [], [], []
    for r in r_edges:
        ref = 2*np.random.random(size=(n, 3)) - 1
        ref /= np.linalg.norm(ref, axis=1).repeat(3).reshape((len(ref), 3))
        ref *= dr*np.random.random(size=(len(ref), 3)) + r
        x, y, z = ref[:, 0], ref[:, 1], ref[:, 2]

        refx_all.append(x)
        refy_all.append(y)
        refz_all.append(z)

    return np.array(refx_all), np.array(refy_all), np.array(refz_all)


class TestPairCorrelation(StrictTestCase):


    def test_correlation_2d_lattice(self):
        ### Lattice Test
        # With proper edge handling, g(r) of the particle at the center should
        # be the same as g(r) for all particles.
        lattice = self._lattice_2d()

        # Calculate g_r on the center particle only (index 210)
        edges, g_r_one = pair_correlation_2d(lattice, dr=.1, cutoff=8, 
                                             p_indices=[210])
        
        #We care about the relative difference of g_r, so let's normalize both.
        g_r_one /= np.linalg.norm(g_r_one) 

        # Calculate g_r on all particles
        edges, g_r_all = pair_correlation_2d(lattice, dr=.1, cutoff=8)
        g_r_all /= np.linalg.norm(g_r_all)

        # Calculate g_r on all particles
        edges, g_r_no_edge = pair_correlation_2d(lattice, dr=.1, cutoff=8, 
                                                 handle_edge=False)
        g_r_no_edge /= np.linalg.norm(g_r_no_edge)

        # Assert the functions are essentially the same
        self.assertTrue(np.allclose(g_r_all, g_r_one, atol=.02))

        # Turning off edge handling should give incorrect result
        self.assertFalse(np.allclose(g_r_all, g_r_no_edge, atol=.02))


    def test_correlation_2d_ring(self):
        # Ring test
        # Generate a series of concentric shells
        # The peaks in g(r) should decay as 1/r.
        ring = self._rings_2d()

        edges, g_r = pair_correlation_2d(ring, dr=.1, cutoff=10, p_indices=[0],
                                         boundary = (-10., 10., -10., 10.))
        g_r /= np.linalg.norm(g_r)
        peaks = g_r[g_r > 0]

        self.assertTrue( len(peaks) == 9 )

        x = np.arange(1,10,1)
        r = peaks.max() * 1/x

        self.assertTrue( np.allclose(peaks, r, atol=.01) )


    def test_correlation3D_ring(self):
        # Ring test
        # Generate a series of concentric shells, 
        # The peaks in g(r) should decay as 1/r^2.
        ring = self._rings_3d()
        edges, g_r = pair_correlation_3d(ring, dr=.1, cutoff=10, 
                                         p_indices=[len(ring) - 1], 
                                         boundary = (-10., 10., -10., 
                                                      10., -10., 10.), 
                                         handle_edge=True)
        g_r /= np.linalg.norm(g_r)
        peaks = g_r[g_r > 0]
        assert len(peaks) == 9
        x = np.arange(1,10,1)
        r = peaks.max() * 1/x**2
        self.assertTrue( np.allclose(peaks, r, atol=.02) )

    def test_correlation_3d_lattice(self):
        ### Lattice Test 
        # With proper edge handling, g(r) of the particle at the center should 
        # be the same as g(r) for all particles.
        lattice = self._lattice_3d(n = 20)

        # Calculate g_r on the center particle only (index 210)
        edges, g_r_one = pair_correlation_3d(lattice, dr=.1, cutoff=7, 
                                             p_indices=[4649])

        # We care about the relative difference of g_r,so let's normalize both.
        g_r_one /= np.linalg.norm(g_r_one) 

        # Calculate g_r on all particles
        edges, g_r_all = pair_correlation_3d(lattice, dr=.1, cutoff=7, 
                                             max_rel_ndensity=2)
        g_r_all /= np.linalg.norm(g_r_all)

        # Calculate g_r on all particles
        edges, g_r_no_edge = pair_correlation_3d(lattice, dr=.1, cutoff=7, 
                                                 handle_edge=False,
                                                 max_rel_ndensity=2.)
        g_r_no_edge /= np.linalg.norm(g_r_no_edge)

        # Assert the functions are essentially the same
        self.assertTrue(np.allclose(g_r_all, g_r_one, atol=.04))

        # Turning off edge handling should give incorrect result
        self.assertFalse(np.allclose(g_r_all, g_r_no_edge, atol=.04))

    def _lattice_2d(self, n = 20):
        # Generates 2D lattice, spacing = 1
        x,y = [],[]
        epsilon = 0.0
        for i in range(n):
            for j in range(n):
                x.append(i)
                y.append(j)

        return pd.DataFrame({'x':x, 'y':y})


    def _rings_2d(self):
        # Generates concentric rings, with a particle at the center
        theta = np.linspace(0, 2*np.pi, 10)
        points = np.zeros((100,2))

        i = 0
        epsilon = .02
        for r in range(10):
            points[i:i+10, 0] = (r + epsilon)*np.cos(theta)
            points[i:i+10, 1] = (r + epsilon)*np.sin(theta)
            i += 10
        points[:10] = 0

        return pd.DataFrame(points, columns = ['x', 'y'])


    def _lattice_3d(self, n = 20):
        # Generates 3D lattice, spacing = 1
        x,y,z = [],[],[]
        for i in range(n):
            for j in range(n):
                for k in range(n):
                    x.append(i)
                    y.append(j)
                    z.append(k)

        return pd.DataFrame({'x':x, 'y':y, 'z':z})


    def _rings_3d(self):
        # Generates concentric spherical shells, with a particle at the center
        epsilon = .02
        r = np.arange(1, 10, 1) + epsilon
        refx, refy, refz = _points_ring3D(r, 0, 500)
        df = pd.DataFrame({'x': np.concatenate(refx),
                               'y': np.concatenate(refy),
                               'z': np.concatenate(refz)})
        
        # The last index is the center particle, which is used to calculate g_r 
        df = df.append(pd.DataFrame({'x': [0.], 'y': [0.], 'z':[0.]}))
        return df


class TestArcLenAndArea(StrictTestCase):
    def setUp(self):
        self.N = 10  # some tests scale with N**2!

    def test_limits(self):
        assert_almost_equal(circle_cap_arclen(0, 1), np.pi)
        assert_almost_equal(circle_corner_arclen(0, 0, 1), np.pi/2)
        assert_almost_equal(sphere_cap_area(0, 1), 2*np.pi)
        assert_almost_equal(sphere_edge_area(0, 0, 1), np.pi)
        assert_almost_equal(sphere_corner_area(0, 0, 0, 1), np.pi/2)

        e = 1 - 10**-10
        e2 = np.sqrt(1/2) - 10**-10
        e3 = np.sqrt(1/3) - 10**-10
        assert_almost_equal(circle_cap_arclen(e, 1), 0, 3)
        assert_almost_equal(circle_corner_arclen(e2, e2, 1), 0, 3)
        assert_almost_equal(sphere_cap_area(e, 1), 0, 3)
        assert_almost_equal(sphere_edge_area(e2, e2, 1), 0, 3)
        assert_almost_equal(sphere_corner_area(e3, e3, e3, 1), 0, 3)

    def test_scaling_circle_cap(self):
        for i in range(self.N):
            h0 = np.random.random()
            R = np.random.random(self.N) * 100
            result = circle_cap_arclen(h0*R, R) / R
            assert_almost_equal(result[1:], result[:-1])

    def test_scaling_circle_corner(self):
        for i in range(self.N):
            h0 = np.random.random()
            h1 = np.random.random() * np.sqrt(1-h0**2)
            R = np.random.random(self.N) * 100
            result = circle_corner_arclen(h0*R, h1*R, R) / R
            assert_almost_equal(result[1:], result[:-1])

    def test_scaling_sphere_cap(self):
        for i in range(self.N):
            h0 = np.random.random()
            R = np.random.random(self.N) * 100
            result = sphere_cap_area(h0*R, R) / R**2
            assert_almost_equal(result[1:], result[:-1])

    def test_scaling_sphere_edge(self):
        for i in range(self.N):
            h0 = np.random.random()
            h1 = np.random.random() * np.sqrt(1-h0**2)
            R = np.random.random(self.N) * 100
            result = sphere_edge_area(h0*R, h1*R, R) / R**2
            assert_almost_equal(result[1:], result[:-1])

    def test_scaling_sphere_corner(self):
        for i in range(self.N):
            h0 = np.random.random()
            h1 = np.random.random() * np.sqrt(1-h0**2)
            h2 = np.random.random() * np.sqrt(1-h0**2-h1**2)
            R = np.random.random(self.N) * 100
            result = sphere_corner_area(h0*R, h1*R, h2*R, R) / R**2
            assert_almost_equal(result[1:], result[:-1])

    def test_symmetry_circle_corner(self):
        R = np.random.random(self.N) * 100
        h0 = np.random.random(self.N) * R
        h1 = np.random.random(self.N) * np.sqrt(R**2-h0**2)
        assert_almost_equal(circle_corner_arclen(h0, h1, R),
                            circle_corner_arclen(h1, h0, R))

    def test_symmetry_sphere_edge(self):
        R = np.random.random(self.N) * 100
        h0 = np.random.random(self.N) * R
        h1 = np.random.random(self.N) * np.sqrt(R**2-h0**2)
        assert_almost_equal(sphere_edge_area(h0, h1, R),
                            sphere_edge_area(h1, h0, R))

    def test_symmetry_sphere_corner(self):
        R = np.random.random(self.N) * 100
        h0 = np.random.random(self.N) * R
        h1 = np.random.random(self.N) * np.sqrt(R**2-h0**2)
        h2 = np.random.random(self.N) * np.sqrt(R**2-h0**2-h1**2)
        result = np.array([sphere_corner_area(h0, h1, h2, R),
                           sphere_corner_area(h1, h2, h0, R),
                           sphere_corner_area(h2, h0, h1, R),
                           sphere_corner_area(h2, h1, h0, R),
                           sphere_corner_area(h0, h2, h1, R),
                           sphere_corner_area(h1, h0, h2, R)])
        assert_almost_equal(result[1:], result[:-1])


class TestNormCircle(StrictTestCase):
    def setUp(self):
        self.R = np.random.random() * 100
        self.point = np.repeat([[self.R, self.R]], 4, axis=0)
        self.box = np.array([[0, 2*self.R], [0, 2*self.R]])

    def test_norm_circle_inside(self):
        dist = np.array([0.001, 0.5, 0.9, 1.0])*self.R
        result = arclen_2d_bounded(dist, self.point, self.box)

        assert_almost_equal(result, 2*np.pi*dist)

    def test_norm_circle_trunc(self):
        dist = np.array([1.0001, 1.1, 1.2, np.sqrt(2)-0.01])*self.R
        result = arclen_2d_bounded(dist, self.point, self.box)

        assert_array_less(result, 2*np.pi*dist)

    def test_norm_circle_outside(self):
        dist = np.array([np.sqrt(2)+0.01, 2, 10, 100])*self.R
        result = arclen_2d_bounded(dist, self.point, self.box)

        assert_almost_equal(result, np.nan, 5)

    def test_norm_circle_limits(self):
        R = self.R
        box = self.box
        # center
        point = np.array([[1, 1]]) * R
        dist = np.repeat([1], point.shape[0], axis=0) * R
        result = arclen_2d_bounded(dist, point, box)
        assert_almost_equal(result, 2*np.pi*R)
        # edges
        point = np.array([[0, 1], [1, 0], [1, 2], [2, 1]]) * R
        dist = np.repeat([1], point.shape[0], axis=0) * R
        result = arclen_2d_bounded(dist, point, box)
        assert_almost_equal(result, np.pi*R)
        # corners
        point = np.array([[0, 0], [2, 0], [0, 2], [2, 2]]) * R
        dist = np.repeat([1], point.shape[0], axis=0) * R
        result = arclen_2d_bounded(dist, point, box)
        assert_almost_equal(result, R*np.pi/2)


class TestNormSphere(StrictTestCase):
    def setUp(self):
        self.R = np.random.random() * 100
        R = self.R
        self.point = np.repeat([[R, R, R]], 4, axis=0)
        self.box = np.array([[0, 2*R], [0, 2*R], [0, 2*R]])

    def test_norm_sphere_inside(self):
        dist = np.array([0.001, 0.5, 0.9, 1.0])*self.R
        result = area_3d_bounded(dist, self.point, self.box)

        assert_almost_equal(result, 4*np.pi*dist**2)

    def test_norm_sphere_trunc(self):
        dist = np.array([1.0001, 1.1, 1.2, np.sqrt(3)-0.01])*self.R
        result = area_3d_bounded(dist, self.point, self.box)

        assert_array_less(result, 4*np.pi*dist**2)

    def test_norm_sphere_outside(self):
        dist = np.array([np.sqrt(3)+0.01, 2, 10, 100])*self.R
        result = area_3d_bounded(dist, self.point, self.box)

        assert_almost_equal(result, np.nan, 5)

    def test_norm_sphere_limits(self):
        R = self.R
        box = self.box
        # center
        point = np.array([[1, 1, 1]]) * R
        dist = np.repeat([1], point.shape[0], axis=0) * R
        result = area_3d_bounded(dist, point, box)
        assert_almost_equal(result, 4*np.pi*R**2)
        # planes
        point = np.array([[0, 1, 1], [1, 1, 0], [1, 0, 1], [2, 1, 1],
                          [1, 1, 2], [1, 2, 1]]) * R
        dist = np.repeat([1], point.shape[0], axis=0) * R
        result = area_3d_bounded(dist, point, box)
        assert_almost_equal(result, 2*np.pi*R**2)
        # edges
        point = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0], [2, 0, 1],
                          [0, 2, 1], [1, 0, 2], [1, 2, 0], [0, 1, 2],
                          [2, 1, 0], [2, 2, 1], [1, 2, 2], [2, 1, 2]]) * R
        dist = np.repeat([1], point.shape[0], axis=0) * R
        result = area_3d_bounded(dist, point, box)
        assert_almost_equal(result, np.pi*R**2)
        # corners
        point = np.array([[0, 0, 0], [0, 0, 2], [0, 2, 0], [2, 0, 0],
                          [0, 2, 2], [2, 2, 0], [2, 0, 2], [2, 2, 2]]) * R
        dist = np.repeat([1], point.shape[0], axis=0) * R
        result = area_3d_bounded(dist, point, box)
        assert_almost_equal(result, 0.5*np.pi*R**2)


def dummy_cluster(N, center, separation, ndim=2):
    devs = (np.random.random((N, ndim)) - 0.5) * separation / np.sqrt(ndim)
    return np.array(center)[np.newaxis, :] + devs


def dummy_clusters(N, max_size, separation, ndim=2):
    center = [separation] * ndim
    sizes = np.random.randint(1, max_size, N)
    displ = (np.random.random((N, ndim)) + 2) * separation
    res = []
    for i, size in enumerate(sizes):
        center += displ[i]
        res.append(dummy_cluster(size, center, separation, ndim))
    return res


def pos_to_df(pos):
    pos_a = np.concatenate(pos)
    ndim = pos_a.shape[1]
    pos_columns = ['z', 'y', 'x'][-ndim:]
    return pd.DataFrame(pos_a, columns=pos_columns)


class TestFindClusters(StrictTestCase):
    def setUp(self):
        self.N = 10

    def test_single_cluster_2D(self):
        separation = np.random.random(self.N) * 10
        for sep in separation:
            pos = dummy_clusters(1, 10, sep)
            df = pos_to_df(pos)
            df = cluster(df, sep)
            assert_equal(df['cluster_size'].values, len(pos[0]))

    def test_multiple_clusters_2D(self):
        numbers = np.random.randint(1, 10, self.N)
        for number in numbers:
            pos = dummy_clusters(number, 10, 1)
            df = pos_to_df(pos)
            df = cluster(df, 1)
            assert_equal(df['cluster'].nunique(), number)

    def test_single_cluster_3D(self):
        separation = np.random.random(self.N) * 10
        for sep in separation:
            pos = dummy_clusters(1, 10, sep, 3)
            df = pos_to_df(pos)
            df = cluster(df, sep)
            assert_equal(df['cluster_size'].values, len(pos[0]))

    def test_multiple_clusters_3D(self):
        numbers = np.random.randint(1, 10, self.N)
        for number in numbers:
            pos = dummy_clusters(number, 10, 1, 3)
            df = pos_to_df(pos)
            df = cluster(df, 1)
            assert_equal(df['cluster'].nunique(), number)

    def test_line_cluster(self):
        separation = np.random.random(self.N) * 10
        angle = np.random.random(self.N) * 2 * np.pi
        ds = np.array([np.cos(angle), np.sin(angle)]).T
        for vec, sep in zip(ds, separation):
            pos = np.arange(10)[:, np.newaxis] * vec[np.newaxis, :] * sep
            df = pos_to_df([pos])
            df = cluster(df, sep*1.1)
            assert_equal(df['cluster_size'].values, 10)
            df = cluster(df, sep*0.9)
            assert_equal(df['cluster_size'].values, 1)

            df = pos_to_df([pos[::-1]])
            df = cluster(df, sep*1.1)
            assert_equal(df['cluster_size'].values, 10)
            df = cluster(df, sep*0.9)
            assert_equal(df['cluster_size'].values, 1)

            ind = np.arange(10)
            np.random.shuffle(ind)
            pos = ind[:, np.newaxis] * vec[np.newaxis, :] * sep
            df = pos_to_df([pos])
            df = cluster(df, sep*1.1)
            assert_equal(df['cluster_size'].values, 10)
            df = cluster(df, sep*0.9)
            assert_equal(df['cluster_size'].values, 1)

    def test_line_cluster_3D(self):
        separation = np.random.random(self.N) * 10
        phi = np.random.random(self.N) * 2 * np.pi
        theta = np.random.random(self.N) * np.pi
        ds = np.array([np.cos(theta),
                       np.cos(phi)*np.sin(theta),
                       np.sin(phi)*np.sin(theta)]).T
        for vec, sep in zip(ds, separation):
            pos = np.arange(10)[:, np.newaxis] * vec[np.newaxis, :] * sep
            df = pos_to_df([pos])
            df = cluster(df, sep*1.1)
            assert_equal(df['cluster_size'].values, 10)
            df = cluster(df, sep*0.9)
            assert_equal(df['cluster_size'].values, 1)

            df = pos_to_df([pos[::-1]])
            df = cluster(df, sep*1.1)
            assert_equal(df['cluster_size'].values, 10)
            df = cluster(df, sep*0.9)
            assert_equal(df['cluster_size'].values, 1)

            ind = np.arange(10)
            np.random.shuffle(ind)
            pos = ind[:, np.newaxis] * vec[np.newaxis, :] * sep
            df = pos_to_df([pos])
            df = cluster(df, sep*1.1)
            assert_equal(df['cluster_size'].values, 10)
            df = cluster(df, sep*0.9)
            assert_equal(df['cluster_size'].values, 1)


if __name__ == '__main__':
    import unittest
    unittest.main()
